generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Stores user information and their relationships
model User {
  user_id       Int     @id @default(autoincrement())
  user_email    String  @unique
  user_name     String
  gender        String
  avatar        String?
  points_gained Int?    @default(0)
  password      String
  timezone      String  @default("UTC") // User's timezone for accurate reminders
  onVacation    Boolean @default(false) // Tracks user's vacation status

  registeredAt DateTime @default(now())
  updatedAt    DateTime @default(now()) @updatedAt

  // User's content and social connections
  blogs            Blog[]
  likes            Like[]
  sentRequests     FriendRequest[] @relation("sentRequests")
  receivedRequests FriendRequest[] @relation("receivedRequests")

  // Chat system connections
  chat_participants ChatParticipant[] // Chats the user participates in
  sent_messages     Message[] // Messages sent by the user
  message_reactions MessageReaction[] // User's emoji reactions to messages

  // Habit tracking related connections
  habits       Habit[] // List of habits created by the user
  habitLogs    HabitLog[] // Record of completed habits
  habitStreaks HabitStreak[] // Tracking of habit streaks
}

// Existing blog-related models
model Blog {
  blog_id          Int      @id @default(autoincrement())
  blog_title       String?
  blog_description String?
  blog_image       String
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  category_id Int
  category    Category @relation(fields: [category_id], references: [category_id])

  user_id Int
  user    User   @relation(fields: [user_id], references: [user_id])
  likes   Like[]
}

model Category {
  category_id   Int    @id @default(autoincrement())
  category_name String

  blogs Blog[]
}

model Like {
  like_id Int @id @default(autoincrement())

  liked_by  Int
  user      User     @relation(fields: [liked_by], references: [user_id])
  blog_id   Int
  blog      Blog     @relation(fields: [blog_id], references: [blog_id])
  createdAt DateTime @default(now())
}

model FriendRequest {
  request_id     Int           @id @default(autoincrement())
  sender_id      Int
  receiver_id    Int
  request_status RequestStatus @default(PENDING)
  createdAt      DateTime      @default(now())

  sender   User @relation(fields: [sender_id], references: [user_id], name: "sentRequests")
  receiver User @relation(fields: [receiver_id], references: [user_id], name: "receivedRequests")
}

enum RequestStatus {
  PENDING
  ACCEPTED
  REJECTED
}

// Different areas of life a habit can belong to (Health, Finance, etc.)
model HabitDomain {
  domain_id   Int      @id @default(autoincrement())
  name        String // Name of the domain (e.g., "Health", "Finance")
  description String? // Optional description of what this domain covers
  icon        String? // Icon for the domain
  createdAt   DateTime @default(now())

  habits Habit[] // Habits that belong to this domain
}

// Types of habit frequency (daily, weekly, monthly, etc.)
model FrequencyType {
  frequency_type_id Int     @id @default(autoincrement())
  name              String // Name of frequency type (e.g., "Daily", "Weekly")
  description       String? // Explanation of the frequency type

  habits Habit[] // Habits using this frequency type
}

// Main habits table - stores all habit information
model Habit {
  habit_id    Int       @id @default(autoincrement())
  name        String // Name of the habit
  description String? // Detailed description of the habit
  start_date  DateTime // When to start tracking this habit
  end_date    DateTime? // Optional end date for temporary habits
  is_active   Boolean   @default(true) // Whether the habit is currently active

  // How often the habit should be done
  frequency_value    Int // Number of times (e.g., 2 times per week)
  frequency_interval Int // Days between repetitions (7 for weekly, 30 for monthly)

  skip_on_vacation Boolean @default(false) // Whether to skip this habit during vacation

  // Dates and timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Connections to other tables
  user_id           Int
  user              User          @relation(fields: [user_id], references: [user_id])
  domain_id         Int
  domain            HabitDomain   @relation(fields: [domain_id], references: [domain_id])
  frequency_type_id Int
  frequencyType     FrequencyType @relation(fields: [frequency_type_id], references: [frequency_type_id])

  // Related records
  schedules HabitSchedule[] // Specific schedule settings
  logs      HabitLog[] // Completion records
  streak    HabitStreak? // Current streak information
  reminders HabitReminder[] // Reminder settings
}

// Specific schedule settings for habits
model HabitSchedule {
  schedule_id  Int        @id @default(autoincrement())
  day_of_week  Int[] // Array of days (1-7) for weekly habits
  day_of_month Int[] // Array of days (1-31) for monthly habits
  times_of_day DateTime[] // Array of times for daily habits
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  habit_id Int
  habit    Habit @relation(fields: [habit_id], references: [habit_id])
}

// Records of completed habits
model HabitLog {
  log_id       Int      @id @default(autoincrement())
  completed_at DateTime // When the habit was completed
  notes        String? // Optional notes about completion
  mood_rating  Int? // Optional mood rating (1-5)
  skipped      Boolean  @default(false) // Whether this log entry represents a skipped habit
  createdAt    DateTime @default(now())

  habit_id Int
  habit    Habit @relation(fields: [habit_id], references: [habit_id])
  user_id  Int
  user     User  @relation(fields: [user_id], references: [user_id])
}

// Tracks streak information for habits
model HabitStreak {
  streak_id         Int       @id @default(autoincrement())
  current_streak    Int       @default(1)
  longest_streak    Int       @default(1)
  start_date        DateTime // When the current streak started
  last_completed_at DateTime? // Last completion date
  updated_at        DateTime  @updatedAt

  habit_id Int   @unique // One streak record per habit
  habit    Habit @relation(fields: [habit_id], references: [habit_id])
  user_id  Int
  user     User  @relation(fields: [user_id], references: [user_id])
}

// Reminder settings for habits
model HabitReminder {
  reminder_id    Int        @id @default(autoincrement())
  reminder_times DateTime[] // Array of times to send reminders
  is_enabled     Boolean    @default(true)
  created_at     DateTime   @default(now())
  updated_at     DateTime   @updatedAt

  habit_id Int
  habit    Habit @relation(fields: [habit_id], references: [habit_id])
}

// Represents a chat space where users can communicate
// Can be either a direct message between two users or a group chat
model ChatRoom {
  room_id    Int      @id @default(autoincrement())
  name       String? // Optional name for group chats (null for DMs)
  type       ChatType @default(DIRECT) // Type of chat room (DIRECT or GROUP)
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  // Related records
  messages     Message[] // All messages in this chat room
  participants ChatParticipant[] // Users participating in this chat room

  @@map("chat_rooms")
}

// Manages user participation in chat rooms and Creates many-to-many relationship between users and chat rooms with additional attributes
model ChatParticipant {
  participant_id Int      @id @default(autoincrement())
  user_id        Int // Reference to the participating user
  room_id        Int // Reference to the chat room
  joined_at      DateTime @default(now()) // When user joined the chat
  last_read_at   DateTime @default(now()) // Timestamp of user's last read
  is_admin       Boolean  @default(false) // Whether user has admin privileges
  is_muted       Boolean  @default(false) // Whether user has muted the chat

  // Connections to other tables
  user      User     @relation(fields: [user_id], references: [user_id])
  chat_room ChatRoom @relation(fields: [room_id], references: [room_id])

  @@unique([user_id, room_id]) // User can only be participant once per room
  @@map("chat_participants")
}

// Stores individual chat messages and their metadata
model Message {
  message_id   Int         @id @default(autoincrement())
  room_id      Int // Reference to the containing chat room
  sender_id    Int // Reference to the message sender
  content      String // Actual message content
  message_type MessageType @default(TEXT) // Type of message content
  is_edited    Boolean     @default(false) // Whether message has been edited
  created_at   DateTime    @default(now())
  updated_at   DateTime    @updatedAt

  // Support for message replies
  reply_to_id Int? // ID of message being replied to (if any)
  reply_to    Message?  @relation("ReplyChain", fields: [reply_to_id], references: [message_id])
  replies     Message[] @relation("ReplyChain") // Messages replying to this one

  // Connections to other tables
  chat_room ChatRoom          @relation(fields: [room_id], references: [room_id])
  sender    User              @relation(fields: [sender_id], references: [user_id])
  reactions MessageReaction[] // Emoji reactions to this message

  @@map("messages")
}

// Tracks emoji reactions to messages and allows users to react to messages with emojis while ensuring unique reactions
model MessageReaction {
  reaction_id Int      @id @default(autoincrement())
  message_id  Int // Reference to the reacted message
  user_id     Int // Reference to the reacting user
  emoji       String // The emoji used for the reaction
  created_at  DateTime @default(now())

  // Connections to other tables
  message Message @relation(fields: [message_id], references: [message_id])
  user    User    @relation(fields: [user_id], references: [user_id])

  @@unique([message_id, user_id, emoji]) // User can only react once with each emoji
  @@map("message_reactions")
}

// Chat system enums
enum ChatType {
  DIRECT // One-on-one chat between two users
  GROUP // Chat room with multiple participants
}

enum MessageType {
  TEXT // Regular text message
  IMAGE // Image attachment
  FILE // File attachment
  SYSTEM // System-generated message
}
